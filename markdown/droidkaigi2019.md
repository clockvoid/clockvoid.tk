# DroidKaigi 2019

Droid Kaigi 2019が開催されました！今日はDroid Kaigiで私が聞いたセッションのメモを残します．

## マルチモジュールでテストはどう変わる？
これまでのアプリでは，app内に複数のパッケージを作っていたが，これからはたくさんモジュール作る

build.gradleに書けば，他のモジュールも使える．
キャッシュにより，ビルド時間が短縮されたりAABに対応できたりする

テストの書き方自体は今までと変わらない．
変えなければ行けないのは，
* DI
* 方針
* メトリクスの収集

### DI
悩みポイント
* モジュール間の依存を完結にしたい
    * あるモジュールが必要な要素がそのモジュールそのものの要素に依存している場合
* 依存の定義技をモジュール内に保ちたい
    * DaggerでいうとModuleクラスの定義を使用

### テスト方針
モジュール化のメリットを受けるために，動作確認もモジュール内で管轄できるようにしたほうが良い

モジュール内で動作確認ができれば，全体のAPKをビルドしなくて良かったりするのでよい

→モジュール内でどのような動作確認ができればよいのか？

モノリシックなプロジェクトでは，レイヤーごとにユニットテストしていたが，レイヤに含まれないような部分はテストがなかったり，動作確認が足りなかったりした．
UIテストとか．

モジュールに分けると，モジュールごとにテストのやり方を考えることになるので，テストの漏れモスなくなる？

#### モジュール内のテスト
モジュールの責務とテスト範囲をまずは考える

ユニットテスト，結合テスト，UIテストを考える．

Utilityがたくさん入ったモジュールなら，それぞれユニットテストすればOK

Logic→Logic→Androidプラットフォームの場合，一番上のLogicにユニットテストをその下の2つに結合テストを．また，全部まとめて結合テストをしたりできる

Activity→Logic→プラットフォームの場合，ActivityをUIテストし，その下を結合テストしたり，全部UIテストしたりできる多分，下のLogicとかをモックしないとマズイ場合，前者を使えば良さげ

はじめはユニットテストから導入するとととても良い

結合テストやUIテストは，ユニットテストでは動作確認として不足している部分に追加！
Androidプラットフォームが絡むテストも簡単に導入できるようになってきたので，ガシガシ書くべき→Project Nitrogen:Robokectricでやるか，Virtual Boxでやるか選べる．
今年のQ1からアルファ版がさわれるか？

現状では，Robolectricで実行するにはtextに，Deviceで実験するにはandroidTestにテストを書く

もしテストを書く時間がなくてもテスタビリティは絶対に意識して実装するべき→テストをやるときにリファクタリングからする必要があるため

#### モジュールをまたいだテスト
モジュールごとにテストを完結されるか，まとめてやるか？

モジュールごとのテストは依存しているモジュールをモックすれば良い

モジュールをまたぐと言っても，今までと変わらないw
他のモジュールの依存が渡せてれば難しくない

### テストメトリクス収集
テストメトリクスはテストの実行結果Jacocoのレポートなど

各モジュールのレポートをまとめてみたい場合には，結果のマージが必要になる

普通はJacocoを使うが，PITとかいうやつが存在する

ミューテーションテスト:プロダクトコードを機械的に変換し，テストコードがちゃんと振る舞いをチェックできているかをチェックするツール！！！

PITは，変更して見て，成功したらNGとする．→協会チェックなどの漏れをチェックしてくれるのだ！

なんとAndroid用のGradle Pluginがある！→ただし，マージには対応せず

頑張って対応してるw．

サンプルも登壇者さんが作成

## UnitTest for ViewModel and LiveData
導入するもの
* Speck
    * android-junit5
* MockK
* kotlinx-coroutine-test
* Truth:アサーションのため
* Spec Framework（for Android Studio）

Spec，MockKの使い方は公式サイト

想定するArchitecureはQuickeRと同じ

ViewModelとRepositoryをCoroutineでつなぐ

Statusとか言うseald classを使ってアイテムをくるんでアイテムの読み込み状態を知らせる

distincUntilChange()で重複するイベントを除いてLiveDataにできるw
CoroutineにはViewModel用のスコープが用意されてる．

### コルーチンを起動してアイテムを取得するところのテスト
普通にRepositoryをモックして，所定の関数が呼び出されたかどうかを見ただけw

ただし，普通にやるとCoroutineがメインスレッドを使えないのでエラーが出るが，コルーチンの実行スレッドを変える機能を使えばOK

コルーチンの動きを待てないと落ちる．ViewModel内でコルーチンの終了を検知できるように書き換える．
更に，テストコードのコルーチンの起動をrunBlockingにするこれで，中断があってもテストが通るようになる

### LiveDataのテスト
LiveDataもAndroidのメインスレッドで動くことを前提に作られているため，普通にやると落ちる

JUnitにはこレを何とかする機能があるので，コピーして拡張関数にする

まずはObserverをモックする→ライフサイクルオーナーがないので，observeForeverを使用．→この辺は拡張関数を作ると良い．

最後に，モックしたオブザーバーが期待通りの順番で呼ばれているかどうか確認．

### テストフレンドリーなViewModelの設計
コンストラクタでViewModelのメンバを渡す．（DIする）

ViewModelは分けられるなら分けたほうが良い．ただし，ViewModel同士の連動はNG．

ViewModelにモデルのmapなどが入るとごちゃごちゃするので，この変換してる部分をobjectに切り分ける．あとは，この部分のユニットテストを書けばOK！

テスト対象の関数が別の関数を読んでいる場合:スパイを使う．ViewModelをスパイする．関数の内容を書き換えるらしい．

プロパティにするとMockKならモックできるため，テストしづらかったらプロパティメソッドにしてしまえば良い

いくつかのリポジトリからデータをとってくる場合，いくつかのリポジトリを持っくしなきゃいけないし，死ぬ
その場合，2つのリポジトリからデータを撮ってくる処理を別クラスに切り分ける（UseCase:メソッドを一個だけ作ったクラス．）こうすると，UseCaseをモックするだけ．

→テストをできないところを切り出して，モックして捨ててしまう（もしくはテストできればテストする）という感じ

### まとめ
テストしやすい設計はだいたい良い設計．

## フロントエンドのためのサーバサイドKotlin（BFFを作る話）
BFFとは
* Backends For Frontend
* クライアントとバックエンドサーバの間にサーバを配置（アーキテクチャ上はフロントエンドで，開発もフロントエンドエンジニア）
* 複数のバックエンド（マイクロサービスなど）がバックエンドにある場合，このような中間層があるととても良い
* いろんなサービスから違った形のAPIアクセスがある場合に優位
* APIの集約をしてくれる
* 成約の多いネイティブのコードをシンプルにできますと
* ただし，管理するものが増えてしまう，後方互換性に注意する必要があるなどの問題も

→現状の課題を見て導入するか決める

たくさんの機能を持ったでかいアプリを改善するためにアプリをモジュールに分けてそれごとにチームを作った

→DDDをしたり，Client Fusion（同じ機能をつけるiOSエンジニアとAndroidエンジニアのコミュニケーション）

ここまで来てBFFの必要性が出てくる．1モジュールにiOSようとAndroidように同じ一つのBFFを作った

### 技術選定
* Kotlin
* Spring WebFlux

→並列性とNon-Blocking IO（コンビニのレジを例に説明してる記事がわかりやすい）が必要だった．
プラス，クライアントエンジニアが書くことを考えて，Kotlin．

BFFには静的型つけがあったほうがいい．

Ktorは今だったらいいが，当時はドキュメントが整っていなかった

→本番で安定しているのでOK，Spingは一度整備されれば大丈夫そう．Coroutineはまだ枯れてないのでゴリ押しがある．
最も重要なのはクライアントエンジニアが気持ちよく開発できること

### 実装
BFFは汚れ役なので，理想はもはや通用しない．理想的なきれいな設計原則よりも，シンプルに，実利を考える

ドメインの捉え方がBackendとFrontedが違うときに変換をする→関数でマッピングする．あんまりドメインモデルを育ててオブジェクト指向で書くとかは考えないほうがいいUtilみたいな感じで考える

Fault Tolerant:あるサービスが死んだときに，マイクロサービスならシステム全体は機能を損ないながらも動き続けることができる．これをしっかりするには，意外とフロントエンドの人と一緒にやらないといけない．

Controllerでバージョン分岐！アプリのバージョンで処理を分岐する（これをサーバサイドでやってるのか！）

### 実践
1画面で一つのAPIでもいいが，UseCaseで1つのAPIを作った．遅いAPIがあったときに，それだけ遅いという状況を作るため

全然違うものを一つのものとして抽象化して返す
→どの粒度まで抽象化するか？

APIはクライアントが使いやし水曜に！

### まとめ
クッソ安定！

ただし，あんまり開発されていない・・・（緊急度はそこまで高くないから？）

### マイクロサービスについて
ユーザへの価値提供をすばやく行うために

サーバ側ではすばやく開発できるようになる（アジリティ）しかし，クライントはこのアジリティの恩恵を受けられない．ただ面倒くさいだけに感じる（サーバーの独りよがり？）

できれば，マイクロサービスをアップデートしたら見た目も変わってほしい．

Webの世界だと，Micro Frontendsとか言う概念が存在．サーバがコンポーネントを提供し，クライアントはそのコンポーネントを配置するだけにする

ネイティブなら，モジュール化すれば，モジュールごとにテストをすればよいし，最高

もしくはアプリをでかくしない，Instant Appsを使うなど

クライアントを含めたマイクロサービス戦略を考える！

## Master of Android Theme
Kyashの人

Styleと同じことができる

テーマはグローバルでスタイルはローカル．

AppCompatを使っていつときによくPrimaryColorとかを設定するあれ

ただし，以下の2つの問題が存在する
* AppCompatだけでもテーマがたくさんありすぎる
* attributeが多すぎる
    * すべてのアトリビュートを理解するのは難しい，何を使えばいいかわかっていない人も多い

### テーマの適用
アプリケーション全体のテーマは何かしらのテーマを継承したものを使用し，Activityごとに設定できる

継承はparent=で指定することもできるし，ドットを使って継承関係を示すこともできる．

→いつparent=を使うべきか．
* AppCompatやMaterialCompatなどのライブラリのテーマを継承する場合．
    * res/values-v21/themes.xmlとかすれば，バージョンごとに対応するテーマを作成することができ，アトリビュートの数もそれだけ減っていく

### テーマの命名規則
Theme.AppCompat.Light.DarkACtionBar
prefix.theme(library)name.background brightness.action bar brightness

という感じに名前が作られている．

3つに別れてるだけ．

最後にBridgeがつくとMaterialComponentsのアトリビュートが使えるようになっている．

### テーマの変え方
Activity#setTheme(resId: Int)

Fragmentでは，inflator.cloneContext()で行う

色をvalue-night/colors.xmlとかに分けて夜用のカラーテーマを作っておくと良い

### atributeの適切な設定方法
Android FrameworkとかAppCompatとかMaterialComponentsのコードを読めば良い（暴言）

カテゴリを作ってくれたらしい（7種類）
* color
* drawable
* text appearance
* shape appearance
* widget style
* theme
* window configuration

#### Colors
これは[githubのリポジトリ](https://github.com/konifar/android-theme-attrs-to-markdown-table)
を見て勉強すれば良さげ

テキストカラーとかはMaterialComponentsでもAppCompatでもあまり変わってない

#### Widgets Style
TabLayoutではスタイルを適用しないと何も適用されてない状態になるw

Widgetのattributeを知るためにはAndroid Studioの機能を使えばだいたいわかる．
@style/Widget.〜を調べてみる．

#### Shape Appearance
cornerFamiliとcornerSizeの2つの要素が存在し，それがいろんなWidgetに適用されている

### テーマかスタイル，どちらを使うべき？
まぁ，デザインによるw

テキストの形がWidgetによって違うような場合は，Widgetごとのテーマを書き換えてそれを全体のテーマとして適用させる

### まとめ
* たくさんatributeはあるけど，結局7種類に分けられるよ
* 色や，Widgetのスタイルはデザインによって変えていかないといけないよ
* Matedial Desingのドキュメントとを読んてきれいにデザインしよう
