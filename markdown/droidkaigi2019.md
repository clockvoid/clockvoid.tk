# DroidKaigi 2019

Droid Kaigi 2019が開催されました！今日はDroid Kaigiで私が聞いたセッションのメモを残します．

## マルチモジュールでテストはどう変わる？
これまでのアプリでは，app内に複数のパッケージを作っていたが，これからはたくさんモジュール作る

build.gradleに書けば，他のモジュールも使える．
キャッシュにより，ビルド時間が短縮されたりAABに対応できたりする

テストの書き方自体は今までと変わらない．
変えなければ行けないのは，
* DI
* 方針
* メトリクスの収集

### DI
悩みポイント
* モジュール間の依存を完結にしたい
    * あるモジュールが必要な要素がそのモジュールそのものの要素に依存している場合
* 依存の定義技をモジュール内に保ちたい
    * DaggerでいうとModuleクラスの定義を使用

### テスト方針
モジュール化のメリットを受けるために，動作確認もモジュール内で管轄できるようにしたほうが良い

モジュール内で動作確認ができれば，全体のAPKをビルドしなくて良かったりするのでよい

→モジュール内でどのような動作確認ができればよいのか？

モノリシックなプロジェクトでは，レイヤーごとにユニットテストしていたが，レイヤに含まれないような部分はテストがなかったり，動作確認が足りなかったりした．
UIテストとか．

モジュールに分けると，モジュールごとにテストのやり方を考えることになるので，テストの漏れモスなくなる？

#### モジュール内のテスト
モジュールの責務とテスト範囲をまずは考える

ユニットテスト，結合テスト，UIテストを考える．

Utilityがたくさん入ったモジュールなら，それぞれユニットテストすればOK

Logic→Logic→Androidプラットフォームの場合，一番上のLogicにユニットテストをその下の2つに結合テストを．また，全部まとめて結合テストをしたりできる

Activity→Logic→プラットフォームの場合，ActivityをUIテストし，その下を結合テストしたり，全部UIテストしたりできる多分，下のLogicとかをモックしないとマズイ場合，前者を使えば良さげ

はじめはユニットテストから導入するとととても良い

結合テストやUIテストは，ユニットテストでは動作確認として不足している部分に追加！
Androidプラットフォームが絡むテストも簡単に導入できるようになってきたので，ガシガシ書くべき→Project Nitrogen:Robokectricでやるか，Virtual Boxでやるか選べる．
今年のQ1からアルファ版がさわれるか？

現状では，Robolectricで実行するにはtextに，Deviceで実験するにはandroidTestにテストを書く

もしテストを書く時間がなくてもテスタビリティは絶対に意識して実装するべき→テストをやるときにリファクタリングからする必要があるため

#### モジュールをまたいだテスト
モジュールごとにテストを完結されるか，まとめてやるか？

モジュールごとのテストは依存しているモジュールをモックすれば良い

モジュールをまたぐと言っても，今までと変わらないw
他のモジュールの依存が渡せてれば難しくない

### テストメトリクス収集
テストメトリクスはテストの実行結果Jacocoのレポートなど

各モジュールのレポートをまとめてみたい場合には，結果のマージが必要になる

普通はJacocoを使うが，PITとかいうやつが存在する

ミューテーションテスト:プロダクトコードを機械的に変換し，テストコードがちゃんと振る舞いをチェックできているかをチェックするツール！！！

PITは，変更して見て，成功したらNGとする．→協会チェックなどの漏れをチェックしてくれるのだ！

なんとAndroid用のGradle Pluginがある！→ただし，マージには対応せず

頑張って対応してるw．

サンプルも登壇者さんが作成

## UnitTest for ViewModel and LiveData
導入するもの
* Speck
    * android-junit5
* MockK
* kotlinx-coroutine-test
* Truth:アサーションのため
* Spec Framework（for Android Studio）

Spec，MockKの使い方は公式サイト

想定するArchitecureはQuickeRと同じ

ViewModelとRepositoryをCoroutineでつなぐ

Statusとか言うseald classを使ってアイテムをくるんでアイテムの読み込み状態を知らせる

distincUntilChange()で重複するイベントを除いてLiveDataにできるw
CoroutineにはViewModel用のスコープが用意されてる．

### コルーチンを起動してアイテムを取得するところのテスト
普通にRepositoryをモックして，所定の関数が呼び出されたかどうかを見ただけw

ただし，普通にやるとCoroutineがメインスレッドを使えないのでエラーが出るが，コルーチンの実行スレッドを変える機能を使えばOK

コルーチンの動きを待てないと落ちる．ViewModel内でコルーチンの終了を検知できるように書き換える．
更に，テストコードのコルーチンの起動をrunBlockingにするこれで，中断があってもテストが通るようになる

### LiveDataのテスト
LiveDataもAndroidのメインスレッドで動くことを前提に作られているため，普通にやると落ちる

JUnitにはこレを何とかする機能があるので，コピーして拡張関数にする

まずはObserverをモックする→ライフサイクルオーナーがないので，observeForeverを使用．→この辺は拡張関数を作ると良い．

最後に，モックしたオブザーバーが期待通りの順番で呼ばれているかどうか確認．

### テストフレンドリーなViewModelの設計
コンストラクタでViewModelのメンバを渡す．（DIする）

ViewModelは分けられるなら分けたほうが良い．ただし，ViewModel同士の連動はNG．

ViewModelにモデルのmapなどが入るとごちゃごちゃするので，この変換してる部分をobjectに切り分ける．あとは，この部分のユニットテストを書けばOK！

テスト対象の関数が別の関数を読んでいる場合:スパイを使う．ViewModelをスパイする．関数の内容を書き換えるらしい．

プロパティにするとMockKならモックできるため，テストしづらかったらプロパティメソッドにしてしまえば良い

いくつかのリポジトリからデータをとってくる場合，いくつかのリポジトリを持っくしなきゃいけないし，死ぬ
その場合，2つのリポジトリからデータを撮ってくる処理を別クラスに切り分ける（UseCase:メソッドを一個だけ作ったクラス．）こうすると，UseCaseをモックするだけ．

→テストをできないところを切り出して，モックして捨ててしまう（もしくはテストできればテストする）という感じ

### まとめ
テストしやすい設計はだいたい良い設計．
