# DroidKaigi 2019

<p class="date">2019-02-07</p>

Droid Kaigi 2019が開催されました！今日はDroid Kaigiで私が聞いたセッションのメモを残します．

## マルチモジュールでテストはどう変わる？
これまでのアプリでは，app内に複数のパッケージを作っていたが，これからはたくさんモジュール作る

build.gradleに書けば，他のモジュールも使える．
キャッシュにより，ビルド時間が短縮されたりAABに対応できたりする

テストの書き方自体は今までと変わらない．
変えなければ行けないのは，
* DI
* 方針
* メトリクスの収集

### DI
悩みポイント
* モジュール間の依存を完結にしたい
    * あるモジュールが必要な要素がそのモジュールそのものの要素に依存している場合
* 依存の定義技をモジュール内に保ちたい
    * DaggerでいうとModuleクラスの定義を使用

### テスト方針
モジュール化のメリットを受けるために，動作確認もモジュール内で管轄できるようにしたほうが良い

モジュール内で動作確認ができれば，全体のAPKをビルドしなくて良かったりするのでよい

→モジュール内でどのような動作確認ができればよいのか？

モノリシックなプロジェクトでは，レイヤーごとにユニットテストしていたが，レイヤに含まれないような部分はテストがなかったり，動作確認が足りなかったりした．
UIテストとか．

モジュールに分けると，モジュールごとにテストのやり方を考えることになるので，テストの漏れモスなくなる？

#### モジュール内のテスト
モジュールの責務とテスト範囲をまずは考える

ユニットテスト，結合テスト，UIテストを考える．

Utilityがたくさん入ったモジュールなら，それぞれユニットテストすればOK

Logic→Logic→Androidプラットフォームの場合，一番上のLogicにユニットテストをその下の2つに結合テストを．また，全部まとめて結合テストをしたりできる

Activity→Logic→プラットフォームの場合，ActivityをUIテストし，その下を結合テストしたり，全部UIテストしたりできる多分，下のLogicとかをモックしないとマズイ場合，前者を使えば良さげ

はじめはユニットテストから導入するとととても良い

結合テストやUIテストは，ユニットテストでは動作確認として不足している部分に追加！
Androidプラットフォームが絡むテストも簡単に導入できるようになってきたので，ガシガシ書くべき→Project Nitrogen:Robokectricでやるか，Virtual Boxでやるか選べる．
今年のQ1からアルファ版がさわれるか？

現状では，Robolectricで実行するにはtextに，Deviceで実験するにはandroidTestにテストを書く

もしテストを書く時間がなくてもテスタビリティは絶対に意識して実装するべき→テストをやるときにリファクタリングからする必要があるため

#### モジュールをまたいだテスト
モジュールごとにテストを完結されるか，まとめてやるか？

モジュールごとのテストは依存しているモジュールをモックすれば良い

モジュールをまたぐと言っても，今までと変わらないw
他のモジュールの依存が渡せてれば難しくない

### テストメトリクス収集
テストメトリクスはテストの実行結果Jacocoのレポートなど

各モジュールのレポートをまとめてみたい場合には，結果のマージが必要になる

普通はJacocoを使うが，PITとかいうやつが存在する

ミューテーションテスト:プロダクトコードを機械的に変換し，テストコードがちゃんと振る舞いをチェックできているかをチェックするツール！！！

PITは，変更して見て，成功したらNGとする．→協会チェックなどの漏れをチェックしてくれるのだ！

なんとAndroid用のGradle Pluginがある！→ただし，マージには対応せず

頑張って対応してるw．

サンプルも登壇者さんが作成

## UnitTest for ViewModel and LiveData
導入するもの
* Speck
    * android-junit5
* MockK
* kotlinx-coroutine-test
* Truth:アサーションのため
* Spec Framework（for Android Studio）

Spec，MockKの使い方は公式サイト

想定するArchitecureはQuickeRと同じ

ViewModelとRepositoryをCoroutineでつなぐ

Statusとか言うseald classを使ってアイテムをくるんでアイテムの読み込み状態を知らせる

distincUntilChange()で重複するイベントを除いてLiveDataにできるw
CoroutineにはViewModel用のスコープが用意されてる．

### コルーチンを起動してアイテムを取得するところのテスト
普通にRepositoryをモックして，所定の関数が呼び出されたかどうかを見ただけw

ただし，普通にやるとCoroutineがメインスレッドを使えないのでエラーが出るが，コルーチンの実行スレッドを変える機能を使えばOK

コルーチンの動きを待てないと落ちる．ViewModel内でコルーチンの終了を検知できるように書き換える．
更に，テストコードのコルーチンの起動をrunBlockingにするこれで，中断があってもテストが通るようになる

### LiveDataのテスト
LiveDataもAndroidのメインスレッドで動くことを前提に作られているため，普通にやると落ちる

JUnitにはこレを何とかする機能があるので，コピーして拡張関数にする

まずはObserverをモックする→ライフサイクルオーナーがないので，observeForeverを使用．→この辺は拡張関数を作ると良い．

最後に，モックしたオブザーバーが期待通りの順番で呼ばれているかどうか確認．

### テストフレンドリーなViewModelの設計
コンストラクタでViewModelのメンバを渡す．（DIする）

ViewModelは分けられるなら分けたほうが良い．ただし，ViewModel同士の連動はNG．

ViewModelにモデルのmapなどが入るとごちゃごちゃするので，この変換してる部分をobjectに切り分ける．あとは，この部分のユニットテストを書けばOK！

テスト対象の関数が別の関数を読んでいる場合:スパイを使う．ViewModelをスパイする．関数の内容を書き換えるらしい．

プロパティにするとMockKならモックできるため，テストしづらかったらプロパティメソッドにしてしまえば良い

いくつかのリポジトリからデータをとってくる場合，いくつかのリポジトリを持っくしなきゃいけないし，死ぬ
その場合，2つのリポジトリからデータを撮ってくる処理を別クラスに切り分ける（UseCase:メソッドを一個だけ作ったクラス．）こうすると，UseCaseをモックするだけ．

→テストをできないところを切り出して，モックして捨ててしまう（もしくはテストできればテストする）という感じ

### まとめ
テストしやすい設計はだいたい良い設計．

## フロントエンドのためのサーバサイドKotlin（BFFを作る話）
BFFとは
* Backends For Frontend
* クライアントとバックエンドサーバの間にサーバを配置（アーキテクチャ上はフロントエンドで，開発もフロントエンドエンジニア）
* 複数のバックエンド（マイクロサービスなど）がバックエンドにある場合，このような中間層があるととても良い
* いろんなサービスから違った形のAPIアクセスがある場合に優位
* APIの集約をしてくれる
* 成約の多いネイティブのコードをシンプルにできますと
* ただし，管理するものが増えてしまう，後方互換性に注意する必要があるなどの問題も

→現状の課題を見て導入するか決める

たくさんの機能を持ったでかいアプリを改善するためにアプリをモジュールに分けてそれごとにチームを作った

→DDDをしたり，Client Fusion（同じ機能をつけるiOSエンジニアとAndroidエンジニアのコミュニケーション）

ここまで来てBFFの必要性が出てくる．1モジュールにiOSようとAndroidように同じ一つのBFFを作った

### 技術選定
* Kotlin
* Spring WebFlux

→並列性とNon-Blocking IO（コンビニのレジを例に説明してる記事がわかりやすい）が必要だった．
プラス，クライアントエンジニアが書くことを考えて，Kotlin．

BFFには静的型つけがあったほうがいい．

Ktorは今だったらいいが，当時はドキュメントが整っていなかった

→本番で安定しているのでOK，Spingは一度整備されれば大丈夫そう．Coroutineはまだ枯れてないのでゴリ押しがある．
最も重要なのはクライアントエンジニアが気持ちよく開発できること

### 実装
BFFは汚れ役なので，理想はもはや通用しない．理想的なきれいな設計原則よりも，シンプルに，実利を考える

ドメインの捉え方がBackendとFrontedが違うときに変換をする→関数でマッピングする．あんまりドメインモデルを育ててオブジェクト指向で書くとかは考えないほうがいいUtilみたいな感じで考える

Fault Tolerant:あるサービスが死んだときに，マイクロサービスならシステム全体は機能を損ないながらも動き続けることができる．これをしっかりするには，意外とフロントエンドの人と一緒にやらないといけない．

Controllerでバージョン分岐！アプリのバージョンで処理を分岐する（これをサーバサイドでやってるのか！）

### 実践
1画面で一つのAPIでもいいが，UseCaseで1つのAPIを作った．遅いAPIがあったときに，それだけ遅いという状況を作るため

全然違うものを一つのものとして抽象化して返す
→どの粒度まで抽象化するか？

APIはクライアントが使いやし水曜に！

### まとめ
クッソ安定！

ただし，あんまり開発されていない・・・（緊急度はそこまで高くないから？）

### マイクロサービスについて
ユーザへの価値提供をすばやく行うために

サーバ側ではすばやく開発できるようになる（アジリティ）しかし，クライントはこのアジリティの恩恵を受けられない．ただ面倒くさいだけに感じる（サーバーの独りよがり？）

できれば，マイクロサービスをアップデートしたら見た目も変わってほしい．

Webの世界だと，Micro Frontendsとか言う概念が存在．サーバがコンポーネントを提供し，クライアントはそのコンポーネントを配置するだけにする

ネイティブなら，モジュール化すれば，モジュールごとにテストをすればよいし，最高

もしくはアプリをでかくしない，Instant Appsを使うなど

クライアントを含めたマイクロサービス戦略を考える！

## Master of Android Theme
Kyashの人

Styleと同じことができる

テーマはグローバルでスタイルはローカル．

AppCompatを使っていつときによくPrimaryColorとかを設定するあれ

ただし，以下の2つの問題が存在する
* AppCompatだけでもテーマがたくさんありすぎる
* attributeが多すぎる
    * すべてのアトリビュートを理解するのは難しい，何を使えばいいかわかっていない人も多い

### テーマの適用
アプリケーション全体のテーマは何かしらのテーマを継承したものを使用し，Activityごとに設定できる

継承はparent=で指定することもできるし，ドットを使って継承関係を示すこともできる．

→いつparent=を使うべきか．
* AppCompatやMaterialCompatなどのライブラリのテーマを継承する場合．
    * res/values-v21/themes.xmlとかすれば，バージョンごとに対応するテーマを作成することができ，アトリビュートの数もそれだけ減っていく

### テーマの命名規則
Theme.AppCompat.Light.DarkACtionBar
prefix.theme(library)name.background brightness.action bar brightness

という感じに名前が作られている．

3つに別れてるだけ．

最後にBridgeがつくとMaterialComponentsのアトリビュートが使えるようになっている．

### テーマの変え方
Activity#setTheme(resId: Int)

Fragmentでは，inflator.cloneContext()で行う

色をvalue-night/colors.xmlとかに分けて夜用のカラーテーマを作っておくと良い

### atributeの適切な設定方法
Android FrameworkとかAppCompatとかMaterialComponentsのコードを読めば良い（暴言）

カテゴリを作ってくれたらしい（7種類）
* color
* drawable
* text appearance
* shape appearance
* widget style
* theme
* window configuration

#### Colors
これは[githubのリポジトリ](https://github.com/konifar/android-theme-attrs-to-markdown-table)
を見て勉強すれば良さげ

テキストカラーとかはMaterialComponentsでもAppCompatでもあまり変わってない

#### Widgets Style
TabLayoutではスタイルを適用しないと何も適用されてない状態になるw

Widgetのattributeを知るためにはAndroid Studioの機能を使えばだいたいわかる．
@style/Widget.〜を調べてみる．

#### Shape Appearance
cornerFamiliとcornerSizeの2つの要素が存在し，それがいろんなWidgetに適用されている

### テーマかスタイル，どちらを使うべき？
まぁ，デザインによるw

テキストの形がWidgetによって違うような場合は，Widgetごとのテーマを書き換えてそれを全体のテーマとして適用させる

### まとめ
* たくさんatributeはあるけど，結局7種類に分けられるよ
* 色や，Widgetのスタイルはデザインによって変えていかないといけないよ
* Matedial Desingのドキュメントとを読んてきれいにデザインしよう

## The Good and Bad of Modern Architecture
ユニクロアプリ結構クソ→頑張って直してる

### Clean Arcitecture
真ん中にEntity，これはビジネスルールが入ってる，その周りにUseCase，つまりアプリのビジネスロジックが入ってる更にその周りにInterfaceが入ってて，一番周りにフレームワークが来て，ここに実装がある

周りのモジュールは互いに互いのことを知らない．

Repositoryという言葉は，AndroidのRepository以上の言葉を持っているため，DataManagerと呼ぶべき

このDataManagerにUseCaseがアクセス（ビジネスルールを支配）し，それをViewModelから呼び出す．

その全体をDaggerなどでDIする．

ただし，RepositoryがDataそうに近い場合など，例外もある

### BAD Thing
学習コストが高い

クソ高くないかもしれないけど，高い

DataManagerはUsesCaseを知るべきじゃないのにあるUsecaseに適切なデータを送る必要があるが，そのためにはMapperとか言う謎のものが必要になり，面倒くさい

テストについて2017年のsessoin 56で話をしたが，それにも問題があり，やはり，学習コストの高さを上げていた

新人はなぜこんなにたくさんコード書かなきゃいけないのかよくわからん．

メンテナンス性が下がってくるとバグも多くなり，最後はメンテナンスできなくなってしまう．理想はメンテナンス性が少し下がるくらいでリリースを向かえ，その後修正するというモデル

## Understanding Kotlin Coroutine
技術書店のオーガナイザーでもある

### コルーチンについての背景
コルーチンは軽量なスレッドであり，バックグラウンドスレッドを管理するものである．

コルーチンは中断するものであり，Threadはブロックするものである．

 **コルーチンは中断可能である！** 中断のタイミング，再開のタイミングを提供し，それによって，スレッド全体が止まってしまうことはない→Blockingとの違い

サスペンド関数:コルーチンを中断するタイミングを提供．
書いた処理を逐次実行する点はかわらないが，suspend関数で中断する．これらの空間と普通のメインスレッドをつなぐものがlaunch()

このとりあえず実行して中断して他の処理を行って，また自分に戻ってくることを継続という．

Threadは継続の実装形態の一つである．Coroutineもそうである．

コルーチンは継続により，フォールバックヘルも解決もできる

### コルーチンの中止
非同期に行った処理をちゃんと中止できる！
そのために，コルーチンを実行するスコープ，コルーチンスコープが使われる．

中止するためには，このコルーチンスコープが提供するJobで行うことができる→launch()関数は，このコルーチンスコープでコルーチンを作成するファクトリ

普通，GlobalScopeは使わない

### 実践
launch()での返り値，Job#cancel()をすれば中断可能

### 平行性と並列性の違い
Coroutineとは平行性を扱うための考え方！

平行性は擬似的にジョブを切って，それぞれにリソースを時間的に使い分け，あたかも同時に動いてるように見せるやつ

並列性は本当にCPUが2つあって，それぞれで処理をすること

### 構造化コンカレンシー
コルーチンスコープのこと．

### async,await
suspend関数を普通に使うと，逐次処理する．これを，asyncで囲って帰ってきたオブジェクトをawaitすると，待ち合わせてくれる

このasyncはコルーチンスコープを作る．んで，suspend関数でコルーチンスコープを生成する．

### 現実的な使い方
現実的な問題
* 作るものの規模が大きい
* メインスレッドを止めてはいけない

よいUXを提供するには，バックグラウンドタスクをどう管理するかという問題を持つことになる

Android-sunflower:Googleのサンプル．ここでCoroutineを使ってみる

UIではただ単にViewModelを呼び出すだけ

ViewModelでviewModelScopeでlaunch()する．→Repository ではsuspendk関数を提供する

これは，videModelJobでviewModelScope，viewModelScopeにmainとviewModelJobにしておけば，JobをキャンセルすればOK

RepositoryはwithContext(IO)を使ってスコープを明示したsuspne関数を作る！

### テストコード
MockKとか使わずとも，JUnitでできる

suspned関数に対するテストはrunBlockingを使えばOK:Mainスレッドを止めてしまう（非同期じゃなくなる）

ボイラープレートを使うと，ViewModelがシンプルになる

suspendCroutine()を使うことで一旦Coroutineを止めて最後にresumeすれば継続して処理が続くようになる→これを拡張関数で用意して上げれば，どこからでも気軽にawaitできる

Android KTX，coroutine-rxを使うことで，使いやすくなる．

### MVVM以外ではどう使うか
まずは層の隙間を考える．

データフローの問題があるなら，Rxでいい

層ごとに責務の分離をしたいときなど，責務を単一に分解するためにCoroutine Scopeをつかえば強制的に責務が分けられる！

Android特有の部分といかに設計を分けるか？

Android Frameworkの機能を抽象化し，インターフェースを作るのにCoroutineを使うことで，ライフサイクルの分離なども同時にできる！

### まとめ
コルーチンは平行性を保ったコードを簡単に作るための仕組み

大事な，基礎的な言葉を使ってCoroutineを説明できる

複数のコルーチンスコープが互いに関係しあっていて，片方が例外で落ちた場合には，例外の伝搬を使う

コルーチン感の通信もできる→Channel Select

## クロスプラットフォーム モバイルアプリ開発ツール総ざらい
[スライド](https://speakerdeck.com/amay077/native-made-number-droidkaigi?slide=18)がすでに存在

クロスプラットフォームツールはできれば使わないほうが良い

クロスプラットフォームツールを使って両方作るのではなく，片方ネイティブで，片方クロスプラットフォームツールでというやり方もある

FlutterでもCJKのトラブルはある

APIのラッパーが提供されていると，自作APIを作りやすい

## 中規模以上のアプリ開発におけるCIレシピとリリースフロー戦略（ここから二日目）
中規模以上とは
* 二人以上での開発，10人，20人とかではない

### With（マッチングサービス）の現状
もともと3人で開発→4人

リリース二週間に一度

QAは1リリースに付き二日

一ヶ月に大規模リリース一回

人の入れ替わりが大きいと運用が属人化してはならない

### Git-Flow
ブランチ運用はきつい
* 次のリリースではどのブランチを含めるか
* リリースすするまでまったり

git-flow:提唱されたブランチモデルを実現するもの（Gitの拡張）

リリーうブランチは開発が終わった（コードフリーズ）のときにdevelopブランチから作成する

hotfixはmasterから伸ばすのがポイント！

git-flowコマンドを使うと簡単にできる

Featureブランチが巨大になり，プルリクを区切りたい！→
Feature用の派生ブランチを作り，細かくプルリクを出すと良い

### CIツールとブランチ運用
Q.どれを使えばいいの？

A.動けば何でも良い

→ただし，ここでは流行りのBitrise
* GUIで作れるので敷居が低い
    * 属人化，職人化を防げる！！！
* yamlファイルをプロジェクトに含めなくて良い
* アプリ特化
    * 証明書周りのサポートがある！

→正直，他のCIツールでもできる

本番環境とステージングで分けて開発

Unit Testはプルリクをトリガーとして

Internal Deployはデプロイゲートなどでデプロイ．
develop, release, hotfix/*のコミットをトリガーとして用意．

本番リリースはmasterブランチにタグがついたことをトリガーとしてGoogle Playにアップロード！

小さなfeatureをまとめている大きなfeature（ベースリポジトリ）に対してもトリガーを設置

ワークフローの再利用性を考えて同じことを二回書かないというのがコツ

Bitraiseでは，ワークフローの名前の先頭にアンダーバーをつけると組み合わせないと実行できないワークフローを作ることができる

### Google Play Store API
段階的なリリース→実はApp Storeにも存在

Google Playは手動でしか更新できない・・・
→Google Play APIを使って自動化できる・・・？

Google Play Developper API
* リリース
* ストアのリスト編集
* 購買状況の管理

これを使えば，JSONで更新比率とか設定でき，自動更新ができる

[サンプル](https://github.com/KazaKago/StepReleaseDispatcher)あり．

Crashlytics API:クラッシュ状況をクラッシュ時に取得できるが，統計データはくれない→クラッシュ状況を目安に公開をやめるのは目視でやるクラシカ方法がない

## Spec2とMockKとJaCoCoでイケてるユニットテスト環境
スライド:https://speakerdeck.com/subroh0508/spek2-plus-mockk-plus-jacocodeiketeru-unit-testhuan-jing-woshou-niru-rero

Mockitoが主流だった:10年前からある

JUnitも使われてる

→どちらもJavaせいで，Kotlin対応が不十分

### MockK
:Kotlin独自の言語仕様網羅

スタブ，モック，スパイを提供

Androidテスト全書

mockk<T>でモックを作る，everyでモックにメソッドに引数と返り値を指定

verifyにexactryを指定して回数を数えられる

あとは，verify系の関数で処理

Mockitoとの比較
* MockitoはFinalな変数をモックできない（Kotlinでは死）
* MockitoはStatixなメソッドをモックできない（Kontlinでは拡張関数やシングルトンオブジェクトが死）

この辺全部モックできるい，suspend関数も行ける

スタティックオブジェクトはビルド後のクラスへのパスでモックできるw

### Spek2
RubyのRSpecを似た文法．
JUnit5で動作．
Unit Testのみ．ロボレクトリックは無理

descriptionでテストメソッドを指定して，contextを指定して，テスト（it）をする．descriptionなど，Stringで書く．

Spec2のために，JUnit5用のGradle Pluginをインストール．

junitPlatformdでengine.includeしてspec2とjunit-vitage（JUnit5の上でJUnit4を動かするもの）を追加する

### JaCoCo
Codecovと連携すると自動的にビジュアライズされたカバレッジを見られる

一行一行見ることもできる

Gradleタスク
* カバレッジレポート作成
    * 対象ファイルの指定
    * 出力形式の指定
    * 出力先の指定
    * これらをUnit Testが終わったときにトリガー（dependsOn）
* 集計
    * モジュールごとにレポート作成
    * executionDataにパスを渡すと自動的にマージされる
* レポート作成
    * 集計してまとめたものをレポートにする


## Talk about gabage
Dalvicではなるべくメモリサイズを小さくする代わりにメモリ確保が遅かった→なるべくnewをしない設計をしてた

ARTではJIT+AOTを使ってメモリ確保を早くしてヒープ領域を大きく撮った

### メモリの動き
プリミティブ型はStack領域かレジスタにそのまま入る

オブジェクトはヒープ領域に入る

ここで，手動でGCをするには忘れるとメモリリークし，忘れなくてももしかしたらクラッシュする！

自動ならメモリリークもせず，クラッシュもしない．魔法だろ

確保にはどれくらい時間がかかるか
コレクションにはどれだけ時間がかるか？
ヒープをどれだけ使うか

など懸念事項が出る

Dalvicでは，確保して，コレクションを非同期で行い，最後に必要のないオブジェクトを開放するなどした．
入る場所が足りないときは頑張って入れるための開放をするが，それでも足りないときはヒープを大きくする（コスト大）か，エラーを出すしかない

Dakvicはヒープにいい感じに隙間があるときにその隙間以上の大きさのオブジェクトを入れるとエラーが出るwこうなったら何もできない．

ARTでは

RosAllocとか言うAllocatorを使って早くメモリ確保が可能
* スレッド単体での確保
* ページ機構

クッソでかいオブジェクトが入りそうになったら新しいヒープを作って対応．
そこでデフラグメントを行い，とりあえず入れていた領域から入れ直した．
ちょっとコストかかるけど，落ちない！

Minor GCとか言うのを使ってコレクションを行う
* 新しい
* 一時的なオブジェクトの保存が簡単にできる

あとまぁヒープ領域でかくしてデフラグが起きないようになってる

ARTもOSのバージョンごとに進化してる

スレッドごとにメモリ確保して最後にAll Threadにコピーするのがクッソ早くなってる

なんとアセンブリレベルで書き直してる！

O以上では新しいGCを搭載新しいリリースで適用！

オブジェクトプール（再利用）もはやい→オレオだとちょっと遅い・・・

#### メモリまとめ
* メモリ確保しすぎてもまず落ちない
* 自分の思ったとおりの型使って良い
* GCはちょっとオーバーヘッドがまだぬけてない
* レイアウトのメジャーとかタップイベントとかではGCが呼ばれる可能性がある．この辺は気をつけて実装する

デモでもまじで違いがよくわかた．Googleの人すげえ

Androidでレイトレーシングすると凄さがわかるらしい

GCがバックうラウンドで走りすぎるとThread-local alocationが走らない

### CPUキャッシュ
キャッシュがゴミで埋まると遅さが非線形のレベルのスピードで下がる
→GCの動きはまじでシステム全体に影響する

メモリアクセスパターンをいろいろ試してベンチマークしてみて！！！

## Lifecycle,LiveData,ViewModel

### Lifecycle
イベントと状態を記録するもの

LifecycleOwnerを作ることができ，FragmnetActivityとか
Fragmnetとかのライフサイクルを見ることができる

StateSavedなFragmentActivityはImmurable UIになってる
→書き換えられない

onViewStateRestoredとonDestroyViewではLifecycleとViewのライフサイクルが少し違うので注意が必要

ProcessLifecycleOwner→プロセス全体のライフサイクルを管理

バックうラウンドにいったり，アプリを閉じたときに遅延

LifecycleServicez→サービスのライフサイクルを管理

LifecycleObserverを作るにはアノテーションをつけて実装

新しいViewのライフサイクルを作るには？→ライフサイクルが違うので辛い
* Custom LifeccleOwner

### LiveData
さっきのLifecycleOwnerを使って作ったLifecyleOwnerオブジェクト

アクティビティが死んでるとLiveDataはデータを送らない（撮っておく）

postValueではバックルラウンドで，setValueではUIスレッドでデータが入る

変形もカスタムしたやつが作れる
* MediatorLiveData

#### LiveData vs Rx
LiveDataはただのホルダーである．イベントを実行するもんじゃない．

でもLifecycleに基づいて動く

LiveDataReactiveStreamsを使うと併用可能

### ViewModel
Repositoryからデータが飛んできてて，Viewがアクセスしてそのデータを取るようになってる

viewModelScopeというコルーチンスコープも作った．
コルーチンを使ってとりあえずデータのゲットを投げっぱなしにしておいて，キャンセルもできる

## パフォーマンスチューニング
機能単位では責任がわからないような問題が起こるので，機能横断して見るような役職を作成

パフォーマンスとは，ユーザー体験に影響を与える要素

リリース後に発覚しやすい
→テストより前のうローでなんとかできないか？
→再現性が低く，ムズkシイ話題についてかいせず

### UIの問題
* カクツキ
* CPU，GPUの負荷

なぜカクツクのか？→ほとんどのタスクはUIスレッドで実行されるため，あるフレーム更新をするべきタイミングで何かしらの処理が走っているとフレーム更新が入らず，カクつく

マルチスレッディングすれば良い
* メモリリークしがち
    * オブジェクトがいつ生成されて殺されているのかを理解する
    * LeakCanary
    * Android Profiler
    * GCは小さい赤い点→これが多いと何かしら欠点あり
* スレッド生成のオーバーヘッド
    * 再利用もしくは数を少なくする
    * RxならThreadPoolをコントロールしてくれる

レンダリング
* レンダリングは横断的（トラバーサる）な処理のためコストが高い
* LayoutInspector
    * View構造を見られる
    * スナップショットが見られる
* 開発者オプション
* パフォーマンスの基準を明確に

問題
* Overdraw
    * 不要なバックグランド，Drawableを削除する
    * 深いViewを削除する
    * どこにバックグラウンドがあるのかを意識！
    * Fragmentをマージできるところは全部マージしてしまう
* GPUレンダリング対応
    * onDrawでメモリアロケートはだめ
    * loopのCanvas操作はコストが高い→drawLines()を使う
    * オフスクリーン描画に気をつける
        * hasoverlappinglendering
    * 定期実行アニメーションはGPUレンダリングを強制

### データ通信量
メモリキャッシュ
* LruCache

シリアライゼーション
* 直列化
* テキスト（JSON）で取ってくるよりバイナリで取ってきたほうがサイズが小さいらしい
    * Protocol Bufferesでバイナリデータを作るのがベストプライス？
    * 要するに自動的に最適化されたデータを作成して送る

画像のフォーマット
* 基本的にはWebPを使う
* 透過が必要ならPNG
* シンプルな画像ならPNG
    * シンプルとは，曲線ができるだけ少なく，色が少ない

最後は実際に見てより圧縮するか考える

### バッテリ消費
モバイル通信を細切れにすると，Stay Awakeの状態になるので，これを防ぐためにデータ通信を細切れにしない→バッチ処理を行う

割と適当目な場所でバッチ処理すべき

WorkManagerを使うと複数処理をチェインして行うことができる．

ボトルネック
* BatteryHistorian
    * Battery Lebelのイベントの間が短いと問題がある

## Navigation Architecture Component
Distinationは画面

### デザイン原則
Priciples of Navigationという公式のリファレンスがある

* 条件付きだったり，一時的に表示される画面はStrat Distinationにならない
* 遷移の操作はCurrent Distinationでそれに対して行われるべき
* Upボタンはアプリを終了しない
* UpとBackは同じ動作をする
* Deep Linkでも同じスタックが形成

### 作り方
defaultNavAppをTrueにすると，Backボタンでデフォルトの戻る動作をする

### DeepLink
自動的にURLを解析し，適切な場所に戻ることができる

### Toolbar
labelにはsafeargsで取得したデータもつかえる

### DroidKaigi-conference app
Navigation Graphをインタープリトするプログラムで実際に参照が存在するかは見ていないのでできる

マルチモジュールではこうするしかない

## WorkManager
[スライド](https://speakerdeck.com/_atsushisakai/workmanager?slide=10)

アプリ内で写真の表示が遅い特に海外
→数字として分析！→平均的に数字で見ても大きな差

そもそもインフラ的に，データベースが日本にあった．．．

### WorgManager
アプリが終了しても確実に実行したい処理があるときに使える

成約をいろいろできる

API14以降では確実に動く！

### 実装
シンクロナイザ:サーバと端末のSQLiteを同期する機能

大事なのはJobをエンキューするところとExecuteするところ
* 条件付など，実際にはクソ簡単！
* 同時に同じ2つのジョブを追加できないようになってたりしてまじで神っぽい

リトライの挙動はドキュメントが不親切のため，コードと突き合わせて理解する必要がある

アップデートにも注意！前のバージョンでenqueしたジョブが実行されて，型が変わってたりするとバグる

Workerはタイムアウトが設定されている！→チェーンを使う！

キャンセルしてもすぐに止まらないことがある．

デバッグ画面を用意してQA

### テストの記述
テストはロボレクトリックではできない．
instrumental testを使う

これだとストレージとか使い過ぎちゃうので，いい感じに容量制限とか，手動開放とかできるようになっている
